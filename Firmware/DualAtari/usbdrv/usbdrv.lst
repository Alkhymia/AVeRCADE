   1               		.file	"usbdrv.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	usbSetInterrupt
  12               	usbSetInterrupt:
  13               	.LFB4:
  14               		.file 1 "usbdrv/usbdrv.c"
   1:usbdrv/usbdrv.c **** /* Name: usbdrv.c
   2:usbdrv/usbdrv.c ****  * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3:usbdrv/usbdrv.c ****  * Author: Christian Starkjohann
   4:usbdrv/usbdrv.c ****  * Creation Date: 2004-12-29
   5:usbdrv/usbdrv.c ****  * Tabsize: 4
   6:usbdrv/usbdrv.c ****  * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7:usbdrv/usbdrv.c ****  * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8:usbdrv/usbdrv.c ****  * This Revision: $Id: usbdrv.c 791 2010-07-15 15:56:13Z cs $
   9:usbdrv/usbdrv.c ****  */
  10:usbdrv/usbdrv.c **** 
  11:usbdrv/usbdrv.c **** #include "usbportability.h"
  12:usbdrv/usbdrv.c **** #include "usbdrv.h"
  13:usbdrv/usbdrv.c **** #include "oddebug.h"
  14:usbdrv/usbdrv.c **** 
  15:usbdrv/usbdrv.c **** /*
  16:usbdrv/usbdrv.c **** General Description:
  17:usbdrv/usbdrv.c **** This module implements the C-part of the USB driver. See usbdrv.h for a
  18:usbdrv/usbdrv.c **** documentation of the entire driver.
  19:usbdrv/usbdrv.c **** */
  20:usbdrv/usbdrv.c **** 
  21:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  22:usbdrv/usbdrv.c **** 
  23:usbdrv/usbdrv.c **** /* raw USB registers / interface to assembler code: */
  24:usbdrv/usbdrv.c **** uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
  25:usbdrv/usbdrv.c **** uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
  26:usbdrv/usbdrv.c **** uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
  27:usbdrv/usbdrv.c **** uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
  28:usbdrv/usbdrv.c **** uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but no
  29:usbdrv/usbdrv.c **** volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow cont
  30:usbdrv/usbdrv.c **** uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 
  31:usbdrv/usbdrv.c **** uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
  32:usbdrv/usbdrv.c **** volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handsh
  33:usbdrv/usbdrv.c **** uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains hands
  34:usbdrv/usbdrv.c **** #if USB_COUNT_SOF
  35:usbdrv/usbdrv.c **** volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
  36:usbdrv/usbdrv.c **** #endif
  37:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
  38:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus1;
  39:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
  40:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus3;
  41:usbdrv/usbdrv.c **** #   endif
  42:usbdrv/usbdrv.c **** #endif
  43:usbdrv/usbdrv.c **** #if USB_CFG_CHECK_DATA_TOGGLING
  44:usbdrv/usbdrv.c **** uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
  45:usbdrv/usbdrv.c **** #endif
  46:usbdrv/usbdrv.c **** 
  47:usbdrv/usbdrv.c **** /* USB status registers / not shared with asm code */
  48:usbdrv/usbdrv.c **** uchar               *usbMsgPtr;     /* data to transmit next -- ROM or RAM address */
  49:usbdrv/usbdrv.c **** static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
  50:usbdrv/usbdrv.c **** static uchar        usbMsgFlags;    /* flag values see below */
  51:usbdrv/usbdrv.c **** 
  52:usbdrv/usbdrv.c **** #define USB_FLG_MSGPTR_IS_ROM   (1<<6)
  53:usbdrv/usbdrv.c **** #define USB_FLG_USE_USER_RW     (1<<7)
  54:usbdrv/usbdrv.c **** 
  55:usbdrv/usbdrv.c **** /*
  56:usbdrv/usbdrv.c **** optimizing hints:
  57:usbdrv/usbdrv.c **** - do not post/pre inc/dec integer values in operations
  58:usbdrv/usbdrv.c **** - assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
  59:usbdrv/usbdrv.c **** - use narrow scope for variables which should be in X/Y/Z register
  60:usbdrv/usbdrv.c **** - assign char sized expressions to variables to force 8 bit arithmetics
  61:usbdrv/usbdrv.c **** */
  62:usbdrv/usbdrv.c **** 
  63:usbdrv/usbdrv.c **** /* -------------------------- String Descriptors --------------------------- */
  64:usbdrv/usbdrv.c **** 
  65:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS == 0
  66:usbdrv/usbdrv.c **** 
  67:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_0 == 0
  68:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_0
  69:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
  70:usbdrv/usbdrv.c **** const PROGMEM char usbDescriptorString0[] = { /* language descriptor */
  71:usbdrv/usbdrv.c ****     4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
  72:usbdrv/usbdrv.c ****     3,          /* descriptor type */
  73:usbdrv/usbdrv.c ****     0x09, 0x04, /* language index (0x0409 = US-English) */
  74:usbdrv/usbdrv.c **** };
  75:usbdrv/usbdrv.c **** #endif
  76:usbdrv/usbdrv.c **** 
  77:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
  78:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_VENDOR
  79:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
  80:usbdrv/usbdrv.c **** const PROGMEM int  usbDescriptorStringVendor[] = {
  81:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
  82:usbdrv/usbdrv.c ****     USB_CFG_VENDOR_NAME
  83:usbdrv/usbdrv.c **** };
  84:usbdrv/usbdrv.c **** #endif
  85:usbdrv/usbdrv.c **** 
  86:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
  87:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
  88:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
  89:usbdrv/usbdrv.c **** const PROGMEM int  usbDescriptorStringDevice[] = {
  90:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
  91:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_NAME
  92:usbdrv/usbdrv.c **** };
  93:usbdrv/usbdrv.c **** #endif
  94:usbdrv/usbdrv.c **** 
  95:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
  96:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
  97:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
  98:usbdrv/usbdrv.c **** const PROGMEM int usbDescriptorStringSerialNumber[] = {
  99:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
 100:usbdrv/usbdrv.c ****     USB_CFG_SERIAL_NUMBER
 101:usbdrv/usbdrv.c **** };
 102:usbdrv/usbdrv.c **** #endif
 103:usbdrv/usbdrv.c **** 
 104:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
 105:usbdrv/usbdrv.c **** 
 106:usbdrv/usbdrv.c **** /* --------------------------- Device Descriptor --------------------------- */
 107:usbdrv/usbdrv.c **** 
 108:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_DEVICE == 0
 109:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_DEVICE
 110:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
 111:usbdrv/usbdrv.c **** const PROGMEM char usbDescriptorDevice[] = {    /* USB device descriptor */
 112:usbdrv/usbdrv.c ****     18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
 113:usbdrv/usbdrv.c ****     USBDESCR_DEVICE,        /* descriptor type */
 114:usbdrv/usbdrv.c ****     0x10, 0x01,             /* USB version supported */
 115:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_CLASS,
 116:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_SUBCLASS,
 117:usbdrv/usbdrv.c ****     0,                      /* protocol */
 118:usbdrv/usbdrv.c ****     8,                      /* max packet size */
 119:usbdrv/usbdrv.c ****     /* the following two casts affect the first byte of the constant only, but
 120:usbdrv/usbdrv.c ****      * that's sufficient to avoid a warning with the default values.
 121:usbdrv/usbdrv.c ****      */
 122:usbdrv/usbdrv.c ****     (char)USB_CFG_VENDOR_ID,/* 2 bytes */
 123:usbdrv/usbdrv.c ****     (char)USB_CFG_DEVICE_ID,/* 2 bytes */
 124:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_VERSION, /* 2 bytes */
 125:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
 126:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
 127:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
 128:usbdrv/usbdrv.c ****     1,          /* number of configurations */
 129:usbdrv/usbdrv.c **** };
 130:usbdrv/usbdrv.c **** #endif
 131:usbdrv/usbdrv.c **** 
 132:usbdrv/usbdrv.c **** /* ----------------------- Configuration Descriptor ------------------------ */
 133:usbdrv/usbdrv.c **** 
 134:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
 135:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_HID
 136:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
 137:usbdrv/usbdrv.c **** #endif
 138:usbdrv/usbdrv.c **** 
 139:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
 140:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_CONFIGURATION
 141:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
 142:usbdrv/usbdrv.c **** const PROGMEM char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
 143:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
 144:usbdrv/usbdrv.c ****     USBDESCR_CONFIG,    /* descriptor type */
 145:usbdrv/usbdrv.c ****     18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
 146:usbdrv/usbdrv.c ****                 (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
 147:usbdrv/usbdrv.c ****                 /* total length of data returned (including inlined descriptors) */
 148:usbdrv/usbdrv.c ****     1,          /* number of interfaces in this configuration */
 149:usbdrv/usbdrv.c ****     1,          /* index of this configuration */
 150:usbdrv/usbdrv.c ****     0,          /* configuration name string index */
 151:usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 152:usbdrv/usbdrv.c ****     (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
 153:usbdrv/usbdrv.c **** #else
 154:usbdrv/usbdrv.c ****     (1 << 7),                           /* attributes */
 155:usbdrv/usbdrv.c **** #endif
 156:usbdrv/usbdrv.c ****     USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
 157:usbdrv/usbdrv.c **** /* interface descriptor follows inline: */
 158:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
 159:usbdrv/usbdrv.c ****     USBDESCR_INTERFACE, /* descriptor type */
 160:usbdrv/usbdrv.c ****     0,          /* index of this interface */
 161:usbdrv/usbdrv.c ****     0,          /* alternate setting for this interface */
 162:usbdrv/usbdrv.c ****     USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of en
 163:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_CLASS,
 164:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_SUBCLASS,
 165:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_PROTOCOL,
 166:usbdrv/usbdrv.c ****     0,          /* string index for interface */
 167:usbdrv/usbdrv.c **** #if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
 168:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
 169:usbdrv/usbdrv.c ****     USBDESCR_HID,   /* descriptor type: HID */
 170:usbdrv/usbdrv.c ****     0x01, 0x01, /* BCD representation of HID version */
 171:usbdrv/usbdrv.c ****     0x00,       /* target country code */
 172:usbdrv/usbdrv.c ****     0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
 173:usbdrv/usbdrv.c ****     0x22,       /* descriptor type: report */
 174:usbdrv/usbdrv.c ****     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
 175:usbdrv/usbdrv.c **** #endif
 176:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
 177:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 178:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 179:usbdrv/usbdrv.c ****     (char)0x81, /* IN endpoint number 1 */
 180:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 181:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 182:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 183:usbdrv/usbdrv.c **** #endif
 184:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
 185:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 186:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 187:usbdrv/usbdrv.c ****     (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
 188:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 189:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 190:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 191:usbdrv/usbdrv.c **** #endif
 192:usbdrv/usbdrv.c **** };
 193:usbdrv/usbdrv.c **** #endif
 194:usbdrv/usbdrv.c **** 
 195:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 196:usbdrv/usbdrv.c **** 
 197:usbdrv/usbdrv.c **** static inline void  usbResetDataToggling(void)
 198:usbdrv/usbdrv.c **** {
 199:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 201:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 202:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 203:usbdrv/usbdrv.c **** #   endif
 204:usbdrv/usbdrv.c **** #endif
 205:usbdrv/usbdrv.c **** }
 206:usbdrv/usbdrv.c **** 
 207:usbdrv/usbdrv.c **** static inline void  usbResetStall(void)
 208:usbdrv/usbdrv.c **** {
 209:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
 210:usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK;
 211:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 212:usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK;
 213:usbdrv/usbdrv.c **** #endif
 214:usbdrv/usbdrv.c **** #endif
 215:usbdrv/usbdrv.c **** }
 216:usbdrv/usbdrv.c **** 
 217:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 218:usbdrv/usbdrv.c **** 
 219:usbdrv/usbdrv.c **** #if !USB_CFG_SUPPRESS_INTR_CODE
 220:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 221:usbdrv/usbdrv.c **** static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
 222:usbdrv/usbdrv.c **** {
 223:usbdrv/usbdrv.c **** uchar   *p;
 224:usbdrv/usbdrv.c **** char    i;
 225:usbdrv/usbdrv.c **** 
 226:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 227:usbdrv/usbdrv.c ****     if(usbTxLen1 == USBPID_STALL)
 228:usbdrv/usbdrv.c ****         return;
 229:usbdrv/usbdrv.c **** #endif
 230:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 231:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 232:usbdrv/usbdrv.c ****     }else{
 233:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 234:usbdrv/usbdrv.c ****     }
 235:usbdrv/usbdrv.c ****     p = txStatus->buffer + 1;
 236:usbdrv/usbdrv.c ****     i = len;
 237:usbdrv/usbdrv.c ****     do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
 238:usbdrv/usbdrv.c ****         *p++ = *data++;
 239:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 240:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 241:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 242:usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 243:usbdrv/usbdrv.c **** }
 244:usbdrv/usbdrv.c **** 
 245:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 246:usbdrv/usbdrv.c **** {
  15               		.loc 1 246 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22               	/* prologue: function */
  23               	/* frame size = 0 */
  24               	/* stack size = 1 */
  25               	.L__stack_usage = 1
  26 0002 C62F      		mov r28,r22
  27               	.LVL1:
  28               	.LBB24:
  29               	.LBB25:
 230:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
  30               		.loc 1 230 0
  31 0004 2091 0000 		lds r18,usbTxStatus1
  32 0008 24FF      		sbrs r18,4
  33 000a 00C0      		rjmp .L2
 231:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
  34               		.loc 1 231 0
  35 000c 2091 0000 		lds r18,usbTxStatus1+1
  36 0010 38E8      		ldi r19,lo8(-120)
  37 0012 2327      		eor r18,r19
  38 0014 2093 0000 		sts usbTxStatus1+1,r18
  39 0018 00C0      		rjmp .L3
  40               	.L2:
 233:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
  41               		.loc 1 233 0
  42 001a 2AE5      		ldi r18,lo8(90)
  43 001c 2093 0000 		sts usbTxStatus1,r18
  44               	.L3:
  45 0020 DC01      		movw r26,r24
  46               	.LBE25:
  47               	.LBE24:
  48               		.loc 1 246 0
  49 0022 E0E0      		ldi r30,lo8(usbTxStatus1+2)
  50 0024 F0E0      		ldi r31,hi8(usbTxStatus1+2)
  51               	.LBB27:
  52               	.LBB26:
 245:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
  53               		.loc 1 245 0
  54 0026 8C2F      		mov r24,r28
  55               	.LVL2:
  56 0028 8E0F      		add r24,r30
  57               	.LVL3:
  58               	.L4:
 238:usbdrv/usbdrv.c ****         *p++ = *data++;
  59               		.loc 1 238 0
  60 002a 9D91      		ld r25,X+
  61 002c 9193      		st Z+,r25
  62               	.LVL4:
 239:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
  63               		.loc 1 239 0
  64 002e 8E13      		cpse r24,r30
  65 0030 00C0      		rjmp .L4
 240:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
  66               		.loc 1 240 0
  67 0032 6C2F      		mov r22,r28
  68               	.LVL5:
  69 0034 80E0      		ldi r24,lo8(usbTxStatus1+2)
  70 0036 90E0      		ldi r25,hi8(usbTxStatus1+2)
  71 0038 0E94 0000 		call usbCrc16Append
  72               	.LVL6:
 241:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
  73               		.loc 1 241 0
  74 003c CC5F      		subi r28,lo8(-(4))
  75               	.LVL7:
  76 003e C093 0000 		sts usbTxStatus1,r28
  77               	/* epilogue start */
  78               	.LBE26:
  79               	.LBE27:
 247:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus1);
 248:usbdrv/usbdrv.c **** }
  80               		.loc 1 248 0
  81 0042 CF91      		pop r28
  82               	.LVL8:
  83 0044 0895      		ret
  84               		.cfi_endproc
  85               	.LFE4:
  87               	.global	usbPoll
  89               	usbPoll:
  90               	.LFB11:
 249:usbdrv/usbdrv.c **** #endif
 250:usbdrv/usbdrv.c **** 
 251:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 252:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
 253:usbdrv/usbdrv.c **** {
 254:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus3);
 255:usbdrv/usbdrv.c **** }
 256:usbdrv/usbdrv.c **** #endif
 257:usbdrv/usbdrv.c **** #endif /* USB_CFG_SUPPRESS_INTR_CODE */
 258:usbdrv/usbdrv.c **** 
 259:usbdrv/usbdrv.c **** /* ------------------ utilities for code following below ------------------- */
 260:usbdrv/usbdrv.c **** 
 261:usbdrv/usbdrv.c **** /* Use defines for the switch statement so that we can choose between an
 262:usbdrv/usbdrv.c ****  * if()else if() and a switch/case based implementation. switch() is more
 263:usbdrv/usbdrv.c ****  * efficient for a LARGE set of sequential choices, if() is better in all other
 264:usbdrv/usbdrv.c ****  * cases.
 265:usbdrv/usbdrv.c ****  */
 266:usbdrv/usbdrv.c **** #if USB_CFG_USE_SWITCH_STATEMENT
 267:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       switch(cmd){{
 268:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }break; case (value):{
 269:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
 270:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
 271:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }break; default:{
 272:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 273:usbdrv/usbdrv.c **** #else
 274:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
 275:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }else if(_cmd == (value)){
 276:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
 277:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
 278:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }else{
 279:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 280:usbdrv/usbdrv.c **** #endif
 281:usbdrv/usbdrv.c **** 
 282:usbdrv/usbdrv.c **** #ifndef USB_RX_USER_HOOK
 283:usbdrv/usbdrv.c **** #define USB_RX_USER_HOOK(data, len)
 284:usbdrv/usbdrv.c **** #endif
 285:usbdrv/usbdrv.c **** #ifndef USB_SET_ADDRESS_HOOK
 286:usbdrv/usbdrv.c **** #define USB_SET_ADDRESS_HOOK()
 287:usbdrv/usbdrv.c **** #endif
 288:usbdrv/usbdrv.c **** 
 289:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 290:usbdrv/usbdrv.c **** 
 291:usbdrv/usbdrv.c **** /* We use if() instead of #if in the macro below because #if can't be used
 292:usbdrv/usbdrv.c ****  * in macros and the compiler optimizes constant conditions anyway.
 293:usbdrv/usbdrv.c ****  * This may cause problems with undefined symbols if compiled without
 294:usbdrv/usbdrv.c ****  * optimizing!
 295:usbdrv/usbdrv.c ****  */
 296:usbdrv/usbdrv.c **** #define GET_DESCRIPTOR(cfgProp, staticName)         \
 297:usbdrv/usbdrv.c ****     if(cfgProp){                                    \
 298:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_RAM)             \
 299:usbdrv/usbdrv.c ****             flags = 0;                              \
 300:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
 301:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);        \
 302:usbdrv/usbdrv.c ****         }else{                                      \
 303:usbdrv/usbdrv.c ****             len = USB_PROP_LENGTH(cfgProp);         \
 304:usbdrv/usbdrv.c ****             usbMsgPtr = (uchar *)(staticName);      \
 305:usbdrv/usbdrv.c ****         }                                           \
 306:usbdrv/usbdrv.c ****     }
 307:usbdrv/usbdrv.c **** 
 308:usbdrv/usbdrv.c **** /* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 309:usbdrv/usbdrv.c ****  * internally for all types of descriptors.
 310:usbdrv/usbdrv.c ****  */
 311:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
 312:usbdrv/usbdrv.c **** {
 313:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 314:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 315:usbdrv/usbdrv.c **** 
 316:usbdrv/usbdrv.c ****     SWITCH_START(rq->wValue.bytes[1])
 317:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 318:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 319:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 320:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 321:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 322:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 323:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
 324:usbdrv/usbdrv.c ****             flags = 0;
 325:usbdrv/usbdrv.c ****         len = usbFunctionDescriptor(rq);
 326:usbdrv/usbdrv.c **** #else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 327:usbdrv/usbdrv.c ****         SWITCH_START(rq->wValue.bytes[0])
 328:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 329:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 330:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 331:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 332:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 333:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 334:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 335:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumbe
 336:usbdrv/usbdrv.c ****         SWITCH_DEFAULT
 337:usbdrv/usbdrv.c ****             if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 338:usbdrv/usbdrv.c ****                 len = usbFunctionDescriptor(rq);
 339:usbdrv/usbdrv.c ****             }
 340:usbdrv/usbdrv.c ****         SWITCH_END
 341:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 342:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
 343:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 344:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 345:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 346:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 347:usbdrv/usbdrv.c **** #endif
 348:usbdrv/usbdrv.c ****     SWITCH_DEFAULT
 349:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 350:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);
 351:usbdrv/usbdrv.c ****         }
 352:usbdrv/usbdrv.c ****     SWITCH_END
 353:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 354:usbdrv/usbdrv.c ****     return len;
 355:usbdrv/usbdrv.c **** }
 356:usbdrv/usbdrv.c **** 
 357:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 358:usbdrv/usbdrv.c **** 
 359:usbdrv/usbdrv.c **** /* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 360:usbdrv/usbdrv.c ****  * standard requests instead of class and custom requests.
 361:usbdrv/usbdrv.c ****  */
 362:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
 363:usbdrv/usbdrv.c **** {
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 365:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 366:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 367:usbdrv/usbdrv.c **** uchar   index = rq->wIndex.bytes[0];
 368:usbdrv/usbdrv.c **** #endif
 369:usbdrv/usbdrv.c **** 
 370:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 371:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 372:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 373:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 374:usbdrv/usbdrv.c ****         if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
 375:usbdrv/usbdrv.c ****             dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
 376:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 377:usbdrv/usbdrv.c ****         if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
 378:usbdrv/usbdrv.c ****             dataPtr[0] = usbTxLen1 == USBPID_STALL;
 379:usbdrv/usbdrv.c **** #endif
 380:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 381:usbdrv/usbdrv.c ****         len = 2;
 382:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 383:usbdrv/usbdrv.c ****     SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
 384:usbdrv/usbdrv.c ****         if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
 385:usbdrv/usbdrv.c ****             usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
 386:usbdrv/usbdrv.c ****             usbResetDataToggling();
 387:usbdrv/usbdrv.c ****         }
 388:usbdrv/usbdrv.c **** #endif
 389:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 390:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 391:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 392:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 393:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 394:usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 395:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 396:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 397:usbdrv/usbdrv.c ****         len = 1;
 398:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 399:usbdrv/usbdrv.c ****         usbConfiguration = value;
 400:usbdrv/usbdrv.c ****         usbResetStall();
 401:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 402:usbdrv/usbdrv.c ****         len = 1;
 403:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 404:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 405:usbdrv/usbdrv.c ****         usbResetDataToggling();
 406:usbdrv/usbdrv.c ****         usbResetStall();
 407:usbdrv/usbdrv.c **** #endif
 408:usbdrv/usbdrv.c ****     SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
 409:usbdrv/usbdrv.c ****         /* Should we add an optional hook here? */
 410:usbdrv/usbdrv.c ****     SWITCH_END
 411:usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 412:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 413:usbdrv/usbdrv.c ****     return len;
 414:usbdrv/usbdrv.c **** }
 415:usbdrv/usbdrv.c **** 
 416:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 417:usbdrv/usbdrv.c **** 
 418:usbdrv/usbdrv.c **** /* usbProcessRx() is called for every message received by the interrupt
 419:usbdrv/usbdrv.c ****  * routine. It distinguishes between SETUP and DATA packets and processes
 420:usbdrv/usbdrv.c ****  * them accordingly.
 421:usbdrv/usbdrv.c ****  */
 422:usbdrv/usbdrv.c **** static inline void usbProcessRx(uchar *data, uchar len)
 423:usbdrv/usbdrv.c **** {
 424:usbdrv/usbdrv.c **** usbRequest_t    *rq = (void *)data;
 425:usbdrv/usbdrv.c **** 
 426:usbdrv/usbdrv.c **** /* usbRxToken can be:
 427:usbdrv/usbdrv.c ****  * 0x2d 00101101 (USBPID_SETUP for setup data)
 428:usbdrv/usbdrv.c ****  * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
 429:usbdrv/usbdrv.c ****  * 0...0x0f for OUT on endpoint X
 430:usbdrv/usbdrv.c ****  */
 431:usbdrv/usbdrv.c ****     DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
 432:usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
 433:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITEOUT
 434:usbdrv/usbdrv.c ****     if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
 435:usbdrv/usbdrv.c ****         usbFunctionWriteOut(data, len);
 436:usbdrv/usbdrv.c ****         return;
 437:usbdrv/usbdrv.c ****     }
 438:usbdrv/usbdrv.c **** #endif
 439:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 440:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 441:usbdrv/usbdrv.c ****             return;
 442:usbdrv/usbdrv.c ****         usbMsgLen_t replyLen;
 443:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 444:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 445:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 446:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 447:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 448:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 449:usbdrv/usbdrv.c ****         }else{
 450:usbdrv/usbdrv.c ****             replyLen = usbDriverSetup(rq);
 451:usbdrv/usbdrv.c ****         }
 452:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
 453:usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 454:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 455:usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 456:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 457:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 458:usbdrv/usbdrv.c ****                 }else{
 459:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.word;
 460:usbdrv/usbdrv.c ****                 }
 461:usbdrv/usbdrv.c ****             }
 462:usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 463:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 464:usbdrv/usbdrv.c **** #endif
 465:usbdrv/usbdrv.c ****         if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
 466:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 467:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 468:usbdrv/usbdrv.c ****         }else{
 469:usbdrv/usbdrv.c ****             if(replyLen > rq->wLength.word)     /* limit length to max */
 470:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.word;
 471:usbdrv/usbdrv.c ****         }
 472:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 473:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 474:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITE
 475:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 476:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 477:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 478:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 479:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 480:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 481:usbdrv/usbdrv.c ****             }
 482:usbdrv/usbdrv.c ****         }
 483:usbdrv/usbdrv.c **** #endif
 484:usbdrv/usbdrv.c ****     }
 485:usbdrv/usbdrv.c **** }
 486:usbdrv/usbdrv.c **** 
 487:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 488:usbdrv/usbdrv.c **** 
 489:usbdrv/usbdrv.c **** /* This function is similar to usbFunctionRead(), but it's also called for
 490:usbdrv/usbdrv.c ****  * data handled automatically by the driver (e.g. descriptor reads).
 491:usbdrv/usbdrv.c ****  */
 492:usbdrv/usbdrv.c **** static uchar usbDeviceRead(uchar *data, uchar len)
 493:usbdrv/usbdrv.c **** {
 494:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 495:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 496:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 497:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 498:usbdrv/usbdrv.c ****         }else
 499:usbdrv/usbdrv.c **** #endif
 500:usbdrv/usbdrv.c ****         {
 501:usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 502:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 503:usbdrv/usbdrv.c ****                 do{
 504:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 505:usbdrv/usbdrv.c ****                     *data++ = c;
 506:usbdrv/usbdrv.c ****                     r++;
 507:usbdrv/usbdrv.c ****                 }while(--i);
 508:usbdrv/usbdrv.c ****             }else{  /* RAM data */
 509:usbdrv/usbdrv.c ****                 do{
 510:usbdrv/usbdrv.c ****                     *data++ = *r++;
 511:usbdrv/usbdrv.c ****                 }while(--i);
 512:usbdrv/usbdrv.c ****             }
 513:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 514:usbdrv/usbdrv.c ****         }
 515:usbdrv/usbdrv.c ****     }
 516:usbdrv/usbdrv.c ****     return len;
 517:usbdrv/usbdrv.c **** }
 518:usbdrv/usbdrv.c **** 
 519:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 520:usbdrv/usbdrv.c **** 
 521:usbdrv/usbdrv.c **** /* usbBuildTxBlock() is called when we have data to transmit and the
 522:usbdrv/usbdrv.c ****  * interrupt routine's transmit buffer is empty.
 523:usbdrv/usbdrv.c ****  */
 524:usbdrv/usbdrv.c **** static inline void usbBuildTxBlock(void)
 525:usbdrv/usbdrv.c **** {
 526:usbdrv/usbdrv.c **** usbMsgLen_t wantLen;
 527:usbdrv/usbdrv.c **** uchar       len;
 528:usbdrv/usbdrv.c **** 
 529:usbdrv/usbdrv.c ****     wantLen = usbMsgLen;
 530:usbdrv/usbdrv.c ****     if(wantLen > 8)
 531:usbdrv/usbdrv.c ****         wantLen = 8;
 532:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 533:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 534:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 535:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 536:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 537:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 538:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 539:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 540:usbdrv/usbdrv.c ****     }else{
 541:usbdrv/usbdrv.c ****         len = USBPID_STALL;   /* stall the endpoint */
 542:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 543:usbdrv/usbdrv.c ****     }
 544:usbdrv/usbdrv.c ****     usbTxLen = len;
 545:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 546:usbdrv/usbdrv.c **** }
 547:usbdrv/usbdrv.c **** 
 548:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 549:usbdrv/usbdrv.c **** 
 550:usbdrv/usbdrv.c **** static inline void usbHandleResetHook(uchar notResetState)
 551:usbdrv/usbdrv.c **** {
 552:usbdrv/usbdrv.c **** #ifdef USB_RESET_HOOK
 553:usbdrv/usbdrv.c **** static uchar    wasReset;
 554:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 555:usbdrv/usbdrv.c **** 
 556:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 557:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 558:usbdrv/usbdrv.c ****         wasReset = isReset;
 559:usbdrv/usbdrv.c ****     }
 560:usbdrv/usbdrv.c **** #endif
 561:usbdrv/usbdrv.c **** }
 562:usbdrv/usbdrv.c **** 
 563:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 564:usbdrv/usbdrv.c **** 
 565:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 566:usbdrv/usbdrv.c **** {
  91               		.loc 1 566 0
  92               		.cfi_startproc
  93 0046 CF93      		push r28
  94               	.LCFI1:
  95               		.cfi_def_cfa_offset 3
  96               		.cfi_offset 28, -2
  97 0048 DF93      		push r29
  98               	.LCFI2:
  99               		.cfi_def_cfa_offset 4
 100               		.cfi_offset 29, -3
 101               	/* prologue: function */
 102               	/* frame size = 0 */
 103               	/* stack size = 2 */
 104               	.L__stack_usage = 2
 567:usbdrv/usbdrv.c **** schar   len;
 568:usbdrv/usbdrv.c **** uchar   i;
 569:usbdrv/usbdrv.c **** 
 570:usbdrv/usbdrv.c ****     len = usbRxLen - 3;
 105               		.loc 1 570 0
 106 004a 8091 0000 		lds r24,usbRxLen
 107 004e 8350      		subi r24,lo8(-(-3))
 108               	.LVL9:
 571:usbdrv/usbdrv.c ****     if(len >= 0){
 109               		.loc 1 571 0
 110 0050 87FD      		sbrc r24,7
 111 0052 00C0      		rjmp .L7
 572:usbdrv/usbdrv.c **** /* We could check CRC16 here -- but ACK has already been sent anyway. If you
 573:usbdrv/usbdrv.c ****  * need data integrity checks with this driver, check the CRC in your app
 574:usbdrv/usbdrv.c ****  * code and report errors back to the host. Since the ACK was already sent,
 575:usbdrv/usbdrv.c ****  * retries must be handled on application level.
 576:usbdrv/usbdrv.c ****  * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 577:usbdrv/usbdrv.c ****  */
 578:usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 112               		.loc 1 578 0
 113 0054 9091 0000 		lds r25,usbInputBufOffset
 114               	.LVL10:
 115               	.LBB49:
 116               	.LBB50:
 439:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 117               		.loc 1 439 0
 118 0058 2091 0000 		lds r18,usbRxToken
 119 005c 2D32      		cpi r18,lo8(45)
 120 005e 01F0      		breq .+2
 121 0060 00C0      		rjmp .L8
 122               	.LBB51:
 440:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 123               		.loc 1 440 0
 124 0062 8830      		cpi r24,lo8(8)
 125 0064 01F0      		breq .+2
 126 0066 00C0      		rjmp .L8
 127               	.LBE51:
 128               	.LBE50:
 129               	.LBE49:
 130               		.loc 1 578 0
 131 0068 CCE0      		ldi r28,lo8(12)
 132 006a D0E0      		ldi r29,0
 133 006c C91B      		sub r28,r25
 134 006e D109      		sbc r29,__zero_reg__
 135 0070 C050      		subi r28,lo8(-(usbRxBuf))
 136 0072 D040      		sbci r29,hi8(-(usbRxBuf))
 137               	.LBB66:
 138               	.LBB65:
 139               	.LBB64:
 443:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 140               		.loc 1 443 0
 141 0074 83EC      		ldi r24,lo8(-61)
 142               	.LVL11:
 143 0076 8093 0000 		sts usbTxBuf,r24
 444:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 144               		.loc 1 444 0
 145 007a 8AE5      		ldi r24,lo8(90)
 146 007c 8093 0000 		sts usbTxLen,r24
 445:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 147               		.loc 1 445 0
 148 0080 1092 0000 		sts usbMsgFlags,__zero_reg__
 149               	.LVL12:
 446:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 150               		.loc 1 446 0
 151 0084 8881      		ld r24,Y
 152 0086 8076      		andi r24,lo8(96)
 153               	.LVL13:
 447:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 154               		.loc 1 447 0
 155 0088 01F0      		breq .L9
 448:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 156               		.loc 1 448 0
 157 008a CE01      		movw r24,r28
 158               	.LVL14:
 159 008c 0E94 0000 		call usbFunctionSetup
 160               	.LVL15:
 161 0090 00C0      		rjmp .L10
 162               	.LVL16:
 163               	.L9:
 164               	.LBB52:
 165               	.LBB53:
 365:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 166               		.loc 1 365 0
 167 0092 9A81      		ldd r25,Y+2
 168               	.LVL17:
 370:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 169               		.loc 1 370 0
 170 0094 1092 0000 		sts usbTxBuf+9,__zero_reg__
 171               	.LBB54:
 371:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 172               		.loc 1 371 0
 173 0098 8981      		ldd r24,Y+1
 174               	.LVL18:
 372:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 175               		.loc 1 372 0
 176 009a 8111      		cpse r24,__zero_reg__
 177 009c 00C0      		rjmp .L11
 178               	.LVL19:
 179               	.LBB55:
 380:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 180               		.loc 1 380 0
 181 009e 1092 0000 		sts usbTxBuf+10,__zero_reg__
 182               	.LVL20:
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 183               		.loc 1 364 0
 184 00a2 20E0      		ldi r18,lo8(usbTxBuf+9)
 185 00a4 30E0      		ldi r19,hi8(usbTxBuf+9)
 186               	.LVL21:
 381:usbdrv/usbdrv.c ****         len = 2;
 187               		.loc 1 381 0
 188 00a6 82E0      		ldi r24,lo8(2)
 189               	.LVL22:
 190 00a8 00C0      		rjmp .L12
 191               	.LVL23:
 192               	.L11:
 193               	.LBE55:
 389:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 194               		.loc 1 389 0
 195 00aa 8530      		cpi r24,lo8(5)
 196 00ac 01F4      		brne .L13
 390:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 197               		.loc 1 390 0
 198 00ae 9093 0000 		sts usbNewDeviceAddr,r25
 199 00b2 00C0      		rjmp .L40
 200               	.L13:
 392:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 201               		.loc 1 392 0
 202 00b4 8630      		cpi r24,lo8(6)
 203 00b6 01F0      		breq .+2
 204 00b8 00C0      		rjmp .L14
 205               	.LBE54:
 206               	.LBE53:
 579:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 580:usbdrv/usbdrv.c ****         if(usbRxLen > 0)    /* only mark as available if not inactivated */
 581:usbdrv/usbdrv.c ****             usbRxLen = 0;
 582:usbdrv/usbdrv.c **** #else
 583:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 584:usbdrv/usbdrv.c **** #endif
 585:usbdrv/usbdrv.c ****     }
 586:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 587:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 588:usbdrv/usbdrv.c ****             usbBuildTxBlock();
 589:usbdrv/usbdrv.c ****         }
 590:usbdrv/usbdrv.c ****     }
 591:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 592:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 593:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
 594:usbdrv/usbdrv.c ****             goto isNotReset;
 595:usbdrv/usbdrv.c ****     }
 596:usbdrv/usbdrv.c ****     /* RESET condition, called multiple times during reset */
 597:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 598:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 599:usbdrv/usbdrv.c ****     usbResetStall();
 600:usbdrv/usbdrv.c ****     DBG1(0xff, 0, 0);
 601:usbdrv/usbdrv.c **** isNotReset:
 602:usbdrv/usbdrv.c ****     usbHandleResetHook(i);
 603:usbdrv/usbdrv.c **** }
 604:usbdrv/usbdrv.c **** 
 605:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 606:usbdrv/usbdrv.c **** 
 607:usbdrv/usbdrv.c **** USB_PUBLIC void usbInit(void)
 608:usbdrv/usbdrv.c **** {
 609:usbdrv/usbdrv.c **** #if USB_INTR_CFG_SET != 0
 610:usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 611:usbdrv/usbdrv.c **** #endif
 612:usbdrv/usbdrv.c **** #if USB_INTR_CFG_CLR != 0
 613:usbdrv/usbdrv.c ****     USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
 614:usbdrv/usbdrv.c **** #endif
 615:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 616:usbdrv/usbdrv.c ****     usbResetDataToggling();
 617:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 618:usbdrv/usbdrv.c ****     usbTxLen1 = USBPID_NAK;
 619:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 620:usbdrv/usbdrv.c ****     usbTxLen3 = USBPID_NAK;
 621:usbdrv/usbdrv.c **** #endif
 622:usbdrv/usbdrv.c **** #endif
 623:usbdrv/usbdrv.c **** }
 207               		.loc 1 623 0
 208 00ba 8B81      		ldd r24,Y+3
 209               	.LVL24:
 210               	.LBB63:
 211               	.LBB62:
 212               	.LBB56:
 213               	.LBB57:
 214               	.LBB58:
 317:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 215               		.loc 1 317 0
 216 00bc 8130      		cpi r24,lo8(1)
 217 00be 01F4      		brne .L15
 218               	.LVL25:
 318:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 219               		.loc 1 318 0
 220 00c0 80E0      		ldi r24,lo8(usbDescriptorDevice)
 221 00c2 90E0      		ldi r25,hi8(usbDescriptorDevice)
 222               	.LVL26:
 223 00c4 9093 0000 		sts usbMsgPtr+1,r25
 224 00c8 8093 0000 		sts usbMsgPtr,r24
 225 00cc 82E1      		ldi r24,lo8(18)
 226 00ce 00C0      		rjmp .L16
 227               	.LVL27:
 228               	.L15:
 319:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 229               		.loc 1 319 0
 230 00d0 8230      		cpi r24,lo8(2)
 231 00d2 01F4      		brne .L17
 232               	.LVL28:
 320:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 233               		.loc 1 320 0
 234 00d4 80E0      		ldi r24,lo8(usbDescriptorConfiguration)
 235 00d6 90E0      		ldi r25,hi8(usbDescriptorConfiguration)
 236               	.LVL29:
 237 00d8 9093 0000 		sts usbMsgPtr+1,r25
 238 00dc 8093 0000 		sts usbMsgPtr,r24
 239 00e0 82E2      		ldi r24,lo8(34)
 240 00e2 00C0      		rjmp .L16
 241               	.LVL30:
 242               	.L17:
 321:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 243               		.loc 1 321 0
 244 00e4 8330      		cpi r24,lo8(3)
 245 00e6 01F4      		brne .L18
 246               	.LVL31:
 247               	.LBB59:
 328:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 248               		.loc 1 328 0
 249 00e8 9111      		cpse r25,__zero_reg__
 250 00ea 00C0      		rjmp .L19
 251               	.LVL32:
 329:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 252               		.loc 1 329 0
 253 00ec 80E0      		ldi r24,lo8(usbDescriptorString0)
 254 00ee 90E0      		ldi r25,hi8(usbDescriptorString0)
 255               	.LVL33:
 256 00f0 9093 0000 		sts usbMsgPtr+1,r25
 257 00f4 8093 0000 		sts usbMsgPtr,r24
 258 00f8 84E0      		ldi r24,lo8(4)
 259 00fa 00C0      		rjmp .L16
 260               	.LVL34:
 261               	.L19:
 330:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 262               		.loc 1 330 0
 263 00fc 9130      		cpi r25,lo8(1)
 264 00fe 01F4      		brne .L20
 265               	.LVL35:
 331:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 266               		.loc 1 331 0
 267 0100 80E0      		ldi r24,lo8(usbDescriptorStringVendor)
 268 0102 90E0      		ldi r25,hi8(usbDescriptorStringVendor)
 269               	.LVL36:
 270 0104 9093 0000 		sts usbMsgPtr+1,r25
 271 0108 8093 0000 		sts usbMsgPtr,r24
 272 010c 84E3      		ldi r24,lo8(52)
 273 010e 00C0      		rjmp .L16
 274               	.LVL37:
 275               	.L20:
 332:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 276               		.loc 1 332 0
 277 0110 9230      		cpi r25,lo8(2)
 278 0112 01F4      		brne .L37
 279               	.LVL38:
 333:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 280               		.loc 1 333 0
 281 0114 80E0      		ldi r24,lo8(usbDescriptorStringDevice)
 282 0116 90E0      		ldi r25,hi8(usbDescriptorStringDevice)
 283               	.LVL39:
 284 0118 9093 0000 		sts usbMsgPtr+1,r25
 285 011c 8093 0000 		sts usbMsgPtr,r24
 286 0120 8CE1      		ldi r24,lo8(28)
 287 0122 00C0      		rjmp .L16
 288               	.LVL40:
 289               	.L18:
 290               	.LBE59:
 343:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 291               		.loc 1 343 0
 292 0124 8132      		cpi r24,lo8(33)
 293 0126 01F4      		brne .L21
 294               	.LVL41:
 344:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 295               		.loc 1 344 0
 296 0128 80E0      		ldi r24,lo8(usbDescriptorConfiguration+18)
 297 012a 90E0      		ldi r25,hi8(usbDescriptorConfiguration+18)
 298               	.LVL42:
 299 012c 9093 0000 		sts usbMsgPtr+1,r25
 300 0130 8093 0000 		sts usbMsgPtr,r24
 301 0134 89E0      		ldi r24,lo8(9)
 302 0136 00C0      		rjmp .L16
 303               	.LVL43:
 304               	.L21:
 345:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 305               		.loc 1 345 0
 306 0138 8232      		cpi r24,lo8(34)
 307 013a 01F4      		brne .L37
 308               	.LVL44:
 346:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 309               		.loc 1 346 0
 310 013c 80E0      		ldi r24,lo8(usbDescriptorHidReport)
 311 013e 90E0      		ldi r25,hi8(usbDescriptorHidReport)
 312               	.LVL45:
 313 0140 9093 0000 		sts usbMsgPtr+1,r25
 314 0144 8093 0000 		sts usbMsgPtr,r24
 315 0148 85EC      		ldi r24,lo8(-59)
 316 014a 00C0      		rjmp .L16
 317               	.LVL46:
 318               	.L37:
 313:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 319               		.loc 1 313 0
 320 014c 80E0      		ldi r24,0
 321               	.LVL47:
 322               	.L16:
 323               	.LBE58:
 353:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 324               		.loc 1 353 0
 325 014e 90E4      		ldi r25,lo8(64)
 326               	.LVL48:
 327 0150 9093 0000 		sts usbMsgFlags,r25
 328               	.LVL49:
 329 0154 00C0      		rjmp .L10
 330               	.LVL50:
 331               	.L14:
 332               	.LBE57:
 333               	.LBE56:
 395:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 334               		.loc 1 395 0
 335 0156 8830      		cpi r24,lo8(8)
 336 0158 01F0      		breq .L38
 398:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 337               		.loc 1 398 0
 338 015a 8930      		cpi r24,lo8(9)
 339 015c 01F4      		brne .L23
 399:usbdrv/usbdrv.c ****         usbConfiguration = value;
 340               		.loc 1 399 0
 341 015e 9093 0000 		sts usbConfiguration,r25
 342 0162 00C0      		rjmp .L40
 343               	.L23:
 401:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 344               		.loc 1 401 0
 345 0164 8A30      		cpi r24,lo8(10)
 346 0166 01F0      		breq .L39
 404:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 347               		.loc 1 404 0
 348 0168 8B30      		cpi r24,lo8(11)
 349 016a 01F4      		brne .L40
 350               	.LBB60:
 351               	.LBB61:
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 352               		.loc 1 200 0
 353 016c 8BE4      		ldi r24,lo8(75)
 354               	.LVL51:
 355 016e 8093 0000 		sts usbTxStatus1+1,r24
 356 0172 00C0      		rjmp .L40
 357               	.LVL52:
 358               	.L38:
 359               	.LBE61:
 360               	.LBE60:
 396:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 361               		.loc 1 396 0
 362 0174 20E0      		ldi r18,lo8(usbConfiguration)
 363 0176 30E0      		ldi r19,hi8(usbConfiguration)
 364 0178 00C0      		rjmp .L56
 365               	.L39:
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 366               		.loc 1 364 0
 367 017a 20E0      		ldi r18,lo8(usbTxBuf+9)
 368 017c 30E0      		ldi r19,hi8(usbTxBuf+9)
 369               	.LVL53:
 370               	.L56:
 402:usbdrv/usbdrv.c ****         len = 1;
 371               		.loc 1 402 0
 372 017e 81E0      		ldi r24,lo8(1)
 373               	.LVL54:
 374 0180 00C0      		rjmp .L12
 375               	.L40:
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 376               		.loc 1 364 0
 377 0182 20E0      		ldi r18,lo8(usbTxBuf+9)
 378 0184 30E0      		ldi r19,hi8(usbTxBuf+9)
 379               	.LVL55:
 380 0186 80E0      		ldi r24,0
 381               	.LVL56:
 382               	.L12:
 383               	.LBE62:
 411:usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 384               		.loc 1 411 0
 385 0188 3093 0000 		sts usbMsgPtr+1,r19
 386 018c 2093 0000 		sts usbMsgPtr,r18
 387               	.L22:
 388               	.LVL57:
 389               	.L10:
 390               	.LBE63:
 391               	.LBE52:
 466:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 392               		.loc 1 466 0
 393 0190 9F81      		ldd r25,Y+7
 394 0192 9111      		cpse r25,__zero_reg__
 395 0194 00C0      		rjmp .L24
 396 0196 9E81      		ldd r25,Y+6
 397 0198 9817      		cp r25,r24
 398 019a 00F4      		brsh .L24
 399 019c 892F      		mov r24,r25
 400               	.LVL58:
 401               	.L24:
 472:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 402               		.loc 1 472 0
 403 019e 8093 0000 		sts usbMsgLen,r24
 404               	.LVL59:
 405               	.L8:
 406               	.LBE64:
 407               	.LBE65:
 408               	.LBE66:
 583:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 409               		.loc 1 583 0
 410 01a2 1092 0000 		sts usbRxLen,__zero_reg__
 411               	.L7:
 586:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 412               		.loc 1 586 0
 413 01a6 8091 0000 		lds r24,usbTxLen
 414 01aa 84FF      		sbrs r24,4
 415 01ac 00C0      		rjmp .L26
 587:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 416               		.loc 1 587 0
 417 01ae 8091 0000 		lds r24,usbMsgLen
 418 01b2 8F3F      		cpi r24,lo8(-1)
 419 01b4 01F4      		brne .+2
 420 01b6 00C0      		rjmp .L26
 421               	.LVL60:
 422 01b8 C82F      		mov r28,r24
 423 01ba 8930      		cpi r24,lo8(9)
 424 01bc 00F0      		brlo .L27
 425 01be C8E0      		ldi r28,lo8(8)
 426               	.L27:
 427               	.LVL61:
 428               	.LBB67:
 429               	.LBB68:
 532:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 430               		.loc 1 532 0
 431 01c0 8C1B      		sub r24,r28
 432 01c2 8093 0000 		sts usbMsgLen,r24
 533:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 433               		.loc 1 533 0
 434 01c6 8091 0000 		lds r24,usbTxBuf
 435 01ca 98E8      		ldi r25,lo8(-120)
 436 01cc 8927      		eor r24,r25
 437 01ce 8093 0000 		sts usbTxBuf,r24
 438               	.LVL62:
 439               	.LBB69:
 440               	.LBB70:
 494:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 441               		.loc 1 494 0
 442 01d2 CC23      		tst r28
 443 01d4 01F0      		breq .L28
 444               	.LVL63:
 445               	.LBB71:
 501:usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 446               		.loc 1 501 0
 447 01d6 2091 0000 		lds r18,usbMsgPtr
 448 01da 3091 0000 		lds r19,usbMsgPtr+1
 449               	.LVL64:
 450               	.LBE71:
 451               	.LBE70:
 502:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 452               		.loc 1 502 0
 453 01de 8091 0000 		lds r24,usbMsgFlags
 454               	.LBB76:
 455               	.LBB74:
 456 01e2 86FF      		sbrs r24,6
 457 01e4 00C0      		rjmp .L29
 458 01e6 F901      		movw r30,r18
 459 01e8 A0E0      		ldi r26,lo8(usbTxBuf+1)
 460 01ea B0E0      		ldi r27,hi8(usbTxBuf+1)
 461               	.LVL65:
 565:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 462               		.loc 1 565 0
 463 01ec 8C2F      		mov r24,r28
 464 01ee 8A0F      		add r24,r26
 465               	.LVL66:
 466               	.L30:
 467               	.LBB72:
 468               	.LBB73:
 504:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 469               		.loc 1 504 0
 470               	/* #APP */
 471               	 ;  504 "usbdrv/usbdrv.c" 1
 472 01f0 9491      		lpm r25, Z
 473               		
 474               	 ;  0 "" 2
 475               	.LVL67:
 476               	/* #NOAPP */
 477               	.LBE73:
 505:usbdrv/usbdrv.c ****                     *data++ = c;
 478               		.loc 1 505 0
 479 01f2 9D93      		st X+,r25
 480               	.LVL68:
 506:usbdrv/usbdrv.c ****                     r++;
 481               		.loc 1 506 0
 482 01f4 3196      		adiw r30,1
 483               	.LVL69:
 484               	.LBE72:
 507:usbdrv/usbdrv.c ****                 }while(--i);
 485               		.loc 1 507 0
 486 01f6 8A13      		cpse r24,r26
 487 01f8 00C0      		rjmp .L30
 488 01fa 00C0      		rjmp .L57
 489               	.LVL70:
 490               	.L29:
 491 01fc D901      		movw r26,r18
 502:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 492               		.loc 1 502 0
 493 01fe E0E0      		ldi r30,lo8(usbTxBuf+1)
 494 0200 F0E0      		ldi r31,hi8(usbTxBuf+1)
 495               	.LVL71:
 565:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 496               		.loc 1 565 0
 497 0202 8C2F      		mov r24,r28
 498 0204 8E0F      		add r24,r30
 499               	.LVL72:
 500               	.L32:
 510:usbdrv/usbdrv.c ****                     *data++ = *r++;
 501               		.loc 1 510 0
 502 0206 9D91      		ld r25,X+
 503 0208 9193      		st Z+,r25
 504               	.LVL73:
 511:usbdrv/usbdrv.c ****                 }while(--i);
 505               		.loc 1 511 0
 506 020a 8E13      		cpse r24,r30
 507 020c 00C0      		rjmp .L32
 508               	.LVL74:
 509               	.L57:
 565:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 510               		.loc 1 565 0
 511 020e 8C2F      		mov r24,r28
 512 0210 8150      		subi r24,lo8(-(-1))
 513 0212 90E0      		ldi r25,0
 514 0214 0196      		adiw r24,1
 515 0216 820F      		add r24,r18
 516 0218 931F      		adc r25,r19
 517               	.LVL75:
 513:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 518               		.loc 1 513 0
 519 021a 9093 0000 		sts usbMsgPtr+1,r25
 520 021e 8093 0000 		sts usbMsgPtr,r24
 521               	.LVL76:
 522               	.L28:
 523               	.LBE74:
 524               	.LBE76:
 525               	.LBE69:
 536:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 526               		.loc 1 536 0
 527 0222 6C2F      		mov r22,r28
 528 0224 80E0      		ldi r24,lo8(usbTxBuf+1)
 529 0226 90E0      		ldi r25,hi8(usbTxBuf+1)
 530 0228 0E94 0000 		call usbCrc16Append
 531               	.LVL77:
 537:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 532               		.loc 1 537 0
 533 022c CC5F      		subi r28,lo8(-(4))
 534               	.LVL78:
 538:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 535               		.loc 1 538 0
 536 022e CC30      		cpi r28,lo8(12)
 537 0230 01F0      		breq .L33
 539:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 538               		.loc 1 539 0
 539 0232 8FEF      		ldi r24,lo8(-1)
 540 0234 8093 0000 		sts usbMsgLen,r24
 541               	.L33:
 544:usbdrv/usbdrv.c ****     usbTxLen = len;
 542               		.loc 1 544 0
 543 0238 C093 0000 		sts usbTxLen,r28
 544               	.LVL79:
 545               	.L26:
 546               	.LBB78:
 547               	.LBB77:
 548               	.LBB75:
 502:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 549               		.loc 1 502 0
 550 023c 84E1      		ldi r24,lo8(20)
 551               	.LVL80:
 552               	.L35:
 553               	.LBE75:
 554               	.LBE77:
 555               	.LBE78:
 556               	.LBE68:
 557               	.LBE67:
 558               	.LBB79:
 592:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 559               		.loc 1 592 0
 560 023e 99B1      		in r25,0x9
 561               	.LVL81:
 562 0240 9C70      		andi r25,lo8(12)
 563               	.LVL82:
 593:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
 564               		.loc 1 593 0
 565 0242 01F4      		brne .L6
 566 0244 8150      		subi r24,lo8(-(-1))
 567               	.LBE79:
 591:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 568               		.loc 1 591 0
 569 0246 01F4      		brne .L35
 597:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 570               		.loc 1 597 0
 571 0248 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
 598:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 572               		.loc 1 598 0
 573 024c 1092 0000 		sts usbDeviceAddr,__zero_reg__
 574               	.L34:
 575               	.L6:
 576               	/* epilogue start */
 603:usbdrv/usbdrv.c **** }
 577               		.loc 1 603 0
 578 0250 DF91      		pop r29
 579 0252 CF91      		pop r28
 580 0254 0895      		ret
 581               		.cfi_endproc
 582               	.LFE11:
 584               	.global	usbInit
 586               	usbInit:
 587               	.LFB12:
 608:usbdrv/usbdrv.c **** {
 588               		.loc 1 608 0
 589               		.cfi_startproc
 590               	/* prologue: function */
 591               	/* frame size = 0 */
 592               	/* stack size = 0 */
 593               	.L__stack_usage = 0
 610:usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 594               		.loc 1 610 0
 595 0256 E9E6      		ldi r30,lo8(105)
 596 0258 F0E0      		ldi r31,0
 597 025a 8081      		ld r24,Z
 598 025c 8260      		ori r24,lo8(2)
 599 025e 8083      		st Z,r24
 615:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 600               		.loc 1 615 0
 601 0260 E89A      		sbi 0x1d,0
 602               	.LBB80:
 603               	.LBB81:
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 604               		.loc 1 200 0
 605 0262 8BE4      		ldi r24,lo8(75)
 606 0264 8093 0000 		sts usbTxStatus1+1,r24
 607               	.LBE81:
 608               	.LBE80:
 618:usbdrv/usbdrv.c ****     usbTxLen1 = USBPID_NAK;
 609               		.loc 1 618 0
 610 0268 8AE5      		ldi r24,lo8(90)
 611 026a 8093 0000 		sts usbTxStatus1,r24
 612 026e 0895      		ret
 613               		.cfi_endproc
 614               	.LFE12:
 616               	.global	usbDescriptorConfiguration
 617               		.section	.progmem.data,"a",@progbits
 620               	usbDescriptorConfiguration:
 621 0000 09        		.byte	9
 622 0001 02        		.byte	2
 623 0002 22        		.byte	34
 624 0003 00        		.byte	0
 625 0004 01        		.byte	1
 626 0005 01        		.byte	1
 627 0006 00        		.byte	0
 628 0007 80        		.byte	-128
 629 0008 64        		.byte	100
 630 0009 09        		.byte	9
 631 000a 04        		.byte	4
 632 000b 00        		.byte	0
 633 000c 00        		.byte	0
 634 000d 01        		.byte	1
 635 000e 03        		.byte	3
 636 000f 00        		.byte	0
 637 0010 00        		.byte	0
 638 0011 00        		.byte	0
 639 0012 09        		.byte	9
 640 0013 21        		.byte	33
 641 0014 01        		.byte	1
 642 0015 01        		.byte	1
 643 0016 00        		.byte	0
 644 0017 01        		.byte	1
 645 0018 22        		.byte	34
 646 0019 C5        		.byte	-59
 647 001a 00        		.byte	0
 648 001b 07        		.byte	7
 649 001c 05        		.byte	5
 650 001d 81        		.byte	-127
 651 001e 03        		.byte	3
 652 001f 08        		.byte	8
 653 0020 00        		.byte	0
 654 0021 0A        		.byte	10
 655               	.global	usbDescriptorDevice
 658               	usbDescriptorDevice:
 659 0022 12        		.byte	18
 660 0023 01        		.byte	1
 661 0024 10        		.byte	16
 662 0025 01        		.byte	1
 663 0026 00        		.byte	0
 664 0027 00        		.byte	0
 665 0028 00        		.byte	0
 666 0029 08        		.byte	8
 667 002a C0        		.byte	-64
 668 002b 16        		.byte	22
 669 002c DC        		.byte	-36
 670 002d 06        		.byte	6
 671 002e 00        		.byte	0
 672 002f 01        		.byte	1
 673 0030 01        		.byte	1
 674 0031 02        		.byte	2
 675 0032 00        		.byte	0
 676 0033 01        		.byte	1
 677               	.global	usbDescriptorStringDevice
 680               	usbDescriptorStringDevice:
 681 0034 1C03      		.word	796
 682 0036 5500      		.word	85
 683 0038 5300      		.word	83
 684 003a 4200      		.word	66
 685 003c 2000      		.word	32
 686 003e 4800      		.word	72
 687 0040 4900      		.word	73
 688 0042 4400      		.word	68
 689 0044 2000      		.word	32
 690 0046 5300      		.word	83
 691 0048 7400      		.word	116
 692 004a 7500      		.word	117
 693 004c 6600      		.word	102
 694 004e 6600      		.word	102
 695               	.global	usbDescriptorStringVendor
 698               	usbDescriptorStringVendor:
 699 0050 3403      		.word	820
 700 0052 6600      		.word	102
 701 0054 7200      		.word	114
 702 0056 6100      		.word	97
 703 0058 6E00      		.word	110
 704 005a 6B00      		.word	107
 705 005c 2E00      		.word	46
 706 005e 6300      		.word	99
 707 0060 6900      		.word	105
 708 0062 7200      		.word	114
 709 0064 6300      		.word	99
 710 0066 6C00      		.word	108
 711 0068 6500      		.word	101
 712 006a 6F00      		.word	111
 713 006c 6600      		.word	102
 714 006e 6300      		.word	99
 715 0070 7500      		.word	117
 716 0072 7200      		.word	114
 717 0074 7200      		.word	114
 718 0076 6500      		.word	101
 719 0078 6E00      		.word	110
 720 007a 7400      		.word	116
 721 007c 2E00      		.word	46
 722 007e 6300      		.word	99
 723 0080 6F00      		.word	111
 724 0082 6D00      		.word	109
 725               	.global	usbDescriptorString0
 728               	usbDescriptorString0:
 729 0084 04        		.byte	4
 730 0085 03        		.byte	3
 731 0086 09        		.byte	9
 732 0087 04        		.byte	4
 733               		.comm	usbMsgPtr,2,1
 734               		.comm	usbTxStatus1,12,1
 735               		.comm	usbTxBuf,11,1
 736               	.global	usbTxLen
 737               		.data
 740               	usbTxLen:
 741 0000 5A        		.byte	90
 742               		.comm	usbRxToken,1,1
 743               		.comm	usbCurrentTok,1,1
 744               		.comm	usbRxLen,1,1
 745               		.comm	usbConfiguration,1,1
 746               		.comm	usbNewDeviceAddr,1,1
 747               		.comm	usbDeviceAddr,1,1
 748               		.comm	usbInputBufOffset,1,1
 749               		.comm	usbRxBuf,22,1
 752               	usbMsgLen:
 753 0001 FF        		.byte	-1
 754               		.local	usbMsgFlags
 755               		.comm	usbMsgFlags,1,1
 756               		.text
 757               	.Letext0:
 758               		.file 2 "c:\\program files (x86)\\atmel\\avr tools\\avr toolchain\\bin\\../lib/gcc/avr/4.7.2/../..
 759               		.file 3 "usbdrv/usbdrv.h"
DEFINED SYMBOLS
                            *ABS*:00000000 usbdrv.c
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:2      *ABS*:0000003e __SP_H__
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:3      *ABS*:0000003d __SP_L__
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:4      *ABS*:0000003f __SREG__
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:6      *ABS*:00000001 __zero_reg__
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:12     .text:00000000 usbSetInterrupt
                            *COM*:0000000c usbTxStatus1
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:89     .text:00000046 usbPoll
                            *COM*:00000001 usbRxLen
                            *COM*:00000001 usbInputBufOffset
                            *COM*:00000001 usbRxToken
                            *COM*:00000016 usbRxBuf
                            *COM*:0000000b usbTxBuf
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:740    .data:00000000 usbTxLen
                             .bss:00000000 usbMsgFlags
                            *COM*:00000001 usbNewDeviceAddr
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:658    .progmem.data:00000022 usbDescriptorDevice
                            *COM*:00000002 usbMsgPtr
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:620    .progmem.data:00000000 usbDescriptorConfiguration
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:728    .progmem.data:00000084 usbDescriptorString0
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:698    .progmem.data:00000050 usbDescriptorStringVendor
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:680    .progmem.data:00000034 usbDescriptorStringDevice
                            *COM*:00000001 usbConfiguration
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:752    .data:00000001 usbMsgLen
                            *COM*:00000001 usbDeviceAddr
C:\Users\user\AppData\Local\Temp\cc7IiV94.s:586    .text:00000256 usbInit
                            *COM*:00000001 usbCurrentTok

UNDEFINED SYMBOLS
usbCrc16Append
usbFunctionSetup
usbDescriptorHidReport
__do_copy_data
__do_clear_bss
